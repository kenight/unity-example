渲染管线主要步骤：

1. 顶点处理 / 顶点着色器 / vert 函数

顶点变换；坐标转换

2. 面处理 / 图元装配

将顶点转换为图元 (顶点构成的三角形面)；面截取；面剔除

3. 光栅化

将一个图元 (三角形面) 转换为若干个片元 (像素点)

4. 像素处理 / 片元着色器 / 像素着色器 / frag 函数

对片元 (像素点) 进行纹理映射；灯光计算

5. Alpha Test

6. Stencil Test / 模板测试

为 shader 中渲染的像素/片元设置一个参考值 Ref 与 stencil buffer 中对应像素点存储的值进行比较，通过的进行渲染否则丢弃

屏幕上每个像素点都有一个 stencil buffer 值，默认为 0，可被设置为 0 - 255

使用 Stencil test 时，通常做法是先用一个 shader 更新 buffer 值，在通过为其他 shader 设置 Ref 来与之前的 buffer 进行比较产生各种特效

7. Depth Test / 深度测试

离摄像机的远近，即深度值 / Z值

深度测试：默认情况下，将当前渲染像素的Z值与 Depth buffer 中对应像素点的Z值进行比较，如果比缓存中的值小，则用新的像素值替换缓存中对应像素点的值，有深度测试之后，物体的渲染顺序就不那么重要，都能按照Z值正常显示

ZWrite：是否写入深度值到 depth buffer 中，默认为 ON，渲染像素如果没有写入深度缓存，表现出来就是通过摄像机看不到该像素(物体)的远近关系

ZTest：通过 ZTest 的像素会将它的深度值写入深度缓存(前提是ZWrite ON)，也会将它的颜色值写入颜色缓存，反之则不会写入到任何数据

假设环境是 摄像机 -> A -> B (相对摄像机来说 B 在 A 后面)，当 B 与 A 进行深度测试时(通过摄像机观察，正当A覆盖B时)

B 像素写入颜色缓存的意义是：B 像素的颜色将覆盖在 A 像素上

B 像素写入深度缓存的意义是：B 看起来是在 A 的后面

注意：摄像机位置变化，可能使进行测试对象发生改变，上面的举例是 B 与 A 进行测试，如果摄像机移到 AB 顶上，则 B 可能是与地面或其他屏幕上的像素进行测试

8. Blend / 混合

控制当前渲染像素与 g buffer 中对应像素如何混合

这时 g buffer 中包含的是完成渲染并已显示到屏幕上的像素

简单的说，就是新渲染像素与缓存中旧的已存在的像素如何进行混合，主要用途是在多个渲染物体(且常是半透明贴图，如草、花瓣等，边缘是透明的贴图)发生交错的情况下，定义当前像素与已渲染像素(如另一片已渲染完成的草像素)之间的混合方式

语法：Blend SrcFactor DstFactor, 新渲染像素 * SrcFactor + 屏幕上已有像素 * DstFactor



总结：

假设 4 个顶点，构成一个 100 * 100 像素的图像

在一帧中 vert 函数运行 4 次，光栅化后将形成 100 * 100 个片元 (像素点)，frag 函数将运行 10000 次逐个处理像素 (在 GPU 中并行处理，速度相对快)

frag 函数的输入参数是上一阶段对顶点插值后的结果，即光栅化后的片元 (像素点)，所以 frag 函数又叫像素着色器

G buffer 中存储着：模板缓存(stencil buffer)、深度缓存(z / depth buffer)、颜色缓存(color / pixel buffer)等信息

片元包括颜色、深度、UV 数据，在纹理映射之后片元就转换成了像素，通常来说片元就是像素


名词说明：

图元 primitives
片元 fragments